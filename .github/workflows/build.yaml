name: Build, Tag, and Release

on:
  push:
    branches:
      - main

permissions:
  contents: write   # allows pushing Git tags
  packages: write   # allows pushing to GHCR

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:

      - name: Start SSH agent with deploy key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Check out repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Update remote URL to use SSH
        env:
          REPOSITORY: ${{ github.repository }}
        run: git remote set-url origin git@github.com:$REPOSITORY.git

      - name: Determine next version from last tag
        id: semver
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          # Fetch all tags (sometimes needed explicitly)
          git fetch --tags --prune

          # Get the latest tag, or 0.0.0 if none
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag: $LATEST_TAG"

          MAJOR=$(echo "$LATEST_TAG" | cut -d '.' -f 1)
          MINOR=$(echo "$LATEST_TAG" | cut -d '.' -f 2)
          PATCH=$(echo "$LATEST_TAG" | cut -d '.' -f 3)

          NEXT_MAJOR=$MAJOR
          NEXT_MINOR=$MINOR
          NEXT_PATCH=$((PATCH + 1))

          # Check commit message for [major] or [minor]
          if [[ "$COMMIT_MESSAGE" =~ \[major\] ]]; then
            NEXT_MAJOR=$((MAJOR + 1))
            NEXT_MINOR=0
            NEXT_PATCH=0
          elif [[ "$COMMIT_MESSAGE" =~ \[minor\] ]]; then
            NEXT_MINOR=$((MINOR + 1))
            NEXT_PATCH=0
          fi

          NEXT_VERSION="${NEXT_MAJOR}.${NEXT_MINOR}.${NEXT_PATCH}"
          echo "Computed next version: $NEXT_VERSION"

          # Export variables
          echo "VERSION=$NEXT_VERSION" >> $GITHUB_ENV
          echo "MAJOR=$NEXT_MAJOR" >> $GITHUB_ENV

      - name: Resolve true commit SHA
        id: sha_resolver
        env:
          EVENT_NAME: ${{ github.event_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          if [[ "$EVENT_NAME" == "push" ]]; then
            ACTUAL_SHA=$(git log --merges --pretty=format:%H -1 | xargs -I{} git show {} --no-patch --format=%P | cut -d' ' -f2)
            echo "TRUE_SHA=${ACTUAL_SHA:-$GITHUB_SHA}" >> $GITHUB_OUTPUT
          else
            echo "TRUE_SHA=$GITHUB_SHA" >> $GITHUB_OUTPUT
          fi

      - name: Get PR metadata
        uses: 8BitJonny/gh-get-current-pr@3.0.0
        id: pr_meta
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          sha: ${{ steps.sha_resolver.outputs.TRUE_SHA }}

      - name: Get Source Branch of the Merged PR
        id: get_branch
        env:
          PR_NUMBER: ${{ steps.pr_meta.outputs.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
        run: |
          echo "Fetching branch name for PR #$PR_NUMBER..."

          BRANCH_NAME=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPOSITORY/pulls/$PR_NUMBER" | jq -r '.head.ref')

          if [[ -z "$BRANCH_NAME" || "$BRANCH_NAME" == "null" ]]; then
            echo "Failed to get branch name for PR #$PR_NUMBER"
            exit 1
          fi

          echo "Branch Name: $BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Find Last Successful Test Run for the Merged PR Branch
        id: find_run
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
        run: |
          echo "Finding last workflow run for branch $BRANCH_NAME..."

          RUN_ID=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPOSITORY/actions/runs?event=pull_request&status=completed&per_page=10" | \
            jq -r ".workflow_runs[] | select(.head_branch==\"$BRANCH_NAME\" and .name==\"Code checks and testing\") | .id" | head -n 1)

          if [[ -z "$RUN_ID" ]]; then
            echo "No workflow run found for branch $BRANCH_NAME"
            exit 1
          fi

          echo "RUN_ID=$RUN_ID" >> $GITHUB_ENV

      - name: Download Coverage Artifact from Last Test Workflow
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ steps.pr_meta.outputs.number }}
        run: |
          echo "Downloading artifact from workflow run ID: $RUN_ID"

          ARTIFACT_URL="https://api.github.com/repos/$REPOSITORY/actions/runs/$RUN_ID/artifacts"
          ARTIFACT_ID=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "$ARTIFACT_URL" | \
            jq -r ".artifacts[] | select(.name==\"coverage-report-$PR_NUMBER\") | .id")

          if [[ -z "$ARTIFACT_ID" ]]; then
            echo "No coverage artifact found for PR #$PR_NUMBER"
            exit 1
          fi

          echo "Artifact ID: $ARTIFACT_ID"

          curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            -L -o coverage.zip \
            "https://api.github.com/repos/$REPOSITORY/actions/artifacts/$ARTIFACT_ID/zip"

          mkdir -p tests
          unzip -o coverage.zip -d tests


      - name: Update VERSION file and commit coverage artifacts
        run: |
          echo "$VERSION" > VERSION
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@sharepass"

          # Check if coverage artifacts exist before committing
          if [ -f "tests/coverage-badge.svg" ] && [ -f "tests/coverage.xml" ]; then
            git add VERSION tests/coverage-badge.svg tests/coverage.xml
            git commit -m "ci: update VERSION file to $VERSION and coverage artifacts [skip ci]"
          else
            git add VERSION
            git commit -m "ci: update VERSION file to $VERSION [skip ci]"
          fi

          git push origin main

      - name: Setup Node.js for npm audit
        uses: actions/setup-node@v6
        with:
          node-version: '25'

      - name: Run npm audit before build
        run: |
          echo "Running npm audit to check for vulnerabilities..."
          npm audit --audit-level=high || \
            (echo "::error::npm audit found vulnerabilities at high level or higher." && \
             echo "Please review and fix vulnerabilities before proceeding." && \
             npm audit --audit-level=high && exit 1)
          echo "npm audit passed - no high or higher vulnerabilities found."

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        run: |
          docker build -t credshare:build -f Dockerfile.sharepass .

      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          severity: 'CRITICAL'
          scanners: 'vuln,secret,misconfig'
          trivyignores: '.trivyignore'
          exit-code: '1'

      - name: Run Trivy image scan
        id: trivy-scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'image'
          scan-ref: 'credshare:build'
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL'
          scanners: 'vuln,secret,misconfig'
          trivyignores: '.trivyignore'
          exit-code: '0'  # Don't fail yet, we'll check the output

      - name: Check for Critical vulnerabilities
        run: |
          # Install jq for JSON parsing
          sudo apt-get update && sudo apt-get install -y jq

          # Count vulnerabilities from JSON output
          CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")

          echo "Critical vulnerabilities: $CRITICAL_COUNT"

          # Display summary using Trivy action output
          if [ -f trivy-results.json ]; then
            echo "=== Vulnerability Summary ==="
            jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | "\(.Severity): \(.VulnerabilityID) - \(.Title)"' trivy-results.json 2>/dev/null || echo "No critical vulnerabilities found in JSON"
          fi

          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "::error::Found $CRITICAL_COUNT critical severity vulnerabilities. Image will not be pushed to GHCR."
            echo "VULN_FOUND=true" >> $GITHUB_ENV
            exit 1
          else
            echo "No critical severity vulnerabilities found. Proceeding with image push."
            echo "VULN_FOUND=false" >> $GITHUB_ENV
          fi

      - name: Generate SBOM
        if: env.VULN_FOUND == 'false'
        run: |
          # Generate SBOM in CycloneDX format (industry standard)
          trivy image --format cyclonedx --output sbom-cyclonedx.json credshare:build

          # Also generate SPDX format for compatibility
          trivy image --format spdx-json --output sbom-spdx.json credshare:build

          echo "SBOM files generated:"
          ls -lh sbom-*.json

      - name: Upload SBOM artifacts
        if: env.VULN_FOUND == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ env.VERSION }}
          path: |
            sbom-cyclonedx.json
            sbom-spdx.json
          retention-days: 90

      - name: Tag Docker image
        if: env.VULN_FOUND == 'false'
        run: |
          echo "Tagging image with version $VERSION ..."
          docker tag credshare:build ghcr.io/remimikalsen/credshare:$VERSION
          docker tag credshare:build ghcr.io/remimikalsen/credshare:v$MAJOR

      - name: Login to GitHub Container Registry
        if: env.VULN_FOUND == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "$GITHUB_TOKEN" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

      - name: Push Docker image
        if: env.VULN_FOUND == 'false'
        run: |
          docker push ghcr.io/remimikalsen/credshare:$VERSION
          docker push ghcr.io/remimikalsen/credshare:v$MAJOR

      - name: Push new Git tag
        run: |
          # Configure Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@sharepass"

          # Create and push the new tag
          git tag "$VERSION" -m "ci: release version $VERSION"
          git push origin "$VERSION"

      - name: Check if PR was squashed
        id: check_squash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ steps.pr_meta.outputs.number }}
        run: |
          # Fetch PR commits using GitHub API and count them using Python
          PR_COMMITS=$(curl -s \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$REPOSITORY/pulls/$PR_NUMBER/commits" | \
            python3 -c "import sys, json; print(len(json.load(sys.stdin)))")

          echo "Commit count: $PR_COMMITS"

          # If there's only one commit, assume it's a squash merge
          if [[ "$PR_COMMITS" -eq 1 ]]; then
            echo "SQUASH_MERGE=true" >> $GITHUB_ENV
          else
            echo "SQUASH_MERGE=false" >> $GITHUB_ENV
          fi

      - name: Get commit messages with SHAs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ steps.pr_meta.outputs.number }}
          GITHUB_EVENT_BEFORE: ${{ github.event.before }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          if [[ "$SQUASH_MERGE" == "true" ]]; then
            # For squash merges, just fetch the single PR commit
            response=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/$REPOSITORY/pulls/$PR_NUMBER/commits")

            echo "$response" \
              | python3 -c "import sys, json; d = json.load(sys.stdin)[0]; print(f\"{d['commit']['message']} ({d['sha'][:7]})\")" \
              > commits.txt
          else
            # For regular merges, exclude lines containing "Merge pull request"
            git log --pretty=format:"%s (%h)" $GITHUB_EVENT_BEFORE..$GITHUB_SHA \
              | grep -v "Merge pull request" \
              > commits.txt
          fi

      - name: Build release notes file
        env:
          PR_TITLE: ${{ steps.pr_meta.outputs.pr_title }}
          PR_BODY: ${{ steps.pr_meta.outputs.pr_body }}
        run: |
          # Create a file for the release notes.
          # Title from the PR:
          echo "## $PR_TITLE" > release_body.md

          # Conditionally add a "Summary" section if there's a PR body.
          if [[ -n "$PR_BODY" ]]; then
            echo "" >> release_body.md
            echo "### Summary" >> release_body.md
            echo "$PR_BODY" >> release_body.md
          fi

          echo "" >> release_body.md
          echo "### Changes" >> release_body.md
          awk '{print "â€¢ " $0}' commits.txt >> release_body.md

          echo "" >> release_body.md
          echo "### Docker Tags" >> release_body.md
          echo "- Stable: [ghcr.io/remimikalsen/credshare:$VERSION](https://ghcr.io/remimikalsen/credshare:$VERSION)" >> release_body.md
          echo "- Major: [ghcr.io/remimikalsen/credshare:v$MAJOR](https://ghcr.io/remimikalsen/credshare:v$MAJOR)" >> release_body.md

      - name: Create GitHub Release
        if: env.VULN_FOUND == 'false'
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.VERSION }}
          name: "Release ${{ env.VERSION }}"
          body_path: release_body.md
          files: |
            sbom-cyclonedx.json
            sbom-spdx.json
          draft: false
          prerelease: false


      - name: Trigger production update
        env:
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          curl -X POST \
            -H "Content-Type: application/json" \
            -H "Secret: $WEBHOOK_SECRET" \
            -d '{"version": "'$VERSION'"}' \
            https://webhooks.theawesomegarage.com/update-credshare
